# 定义及声明 #
## 短变量声明并初始化 ##
如果 变量 已经被声明过，但依然使用:=时编译器会报错，如下：  
`<no new variables on left side of :=>`  
意思是，在“:=”的左边没有新变量出现，意思就是“:=”的左边变量已经被声明了。  
_在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错_，代码如下：  
`conn, err := net.Dial("tcp", "127.0.0.1:8080")`  
`conn2, err := net.Dial("tcp", "127.0.0.1:8080")`

#  数组、字符串和切片 #
## 数组 ##  
数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。数组的长度是数组类型的组成部分。因为数组的长度是数组类型的一个部分，不同长度或不同类型的数据组成的数组都是不同的类型（[4]int,[5]int是不同的类型），因此在**Go 语言中很少直接使用数组（不同长度的数组因为类型不同无法直接赋值_。**  
定义方式:  
```
  var a [3]int                    // 定义长度为 3 的 int 型数组, 元素全部为 0    
  var b = [...]int{1, 2, 3}       // 定义长度为 3 的 int 型数组, 元素为 1, 2, 3   
  var c = [...]int{2: 3, 1: 2}    // 定义长度为 3 的 int 型数组, 元素为 0, 2, 3   
  var d = [...]int{1, 2, 4: 5, 6} // 定义长度为 6 的 int 型数组, 元素为 1, 2, 0, 0, 5, 6
```
Go 语言中数组是值语义。一个数组变量即表示整个数组，它并不是隐式的指向第一个元素的指针（比如 C 语言的数组），而是一个完整的值。当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。如果数组较大的话，数组的赋值也会有较大的开销。为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。
```
var a = [...]int{1, 2, 3} // a 是一个数组
var b = &a                // b 是指向数组的指针
for i, v := range b {     // 通过数组指针迭代数组的元素
	fmt.Println(i, v)
}
```
但是数组指针类型依然不够灵活，因为数组的长度是数组类型的组成部分，**指向不同长度数组的数组指针类型也是完全不同的。**
长度为 0 的数组在内存中并不占用空间。空数组虽然很少直接使用，但是可以用于*强调某种特有类型的操作时避免分配额外的内存空间。*
可以用 fmt.Printf 函数提供的 %T 或 %#v 谓词语法来打印数组的类型和详细信息：
```
	fmt.Printf("b: %T\n", b)  // b: [3]int
	fmt.Printf("b: %#v\n", b) // b: [3]int{1, 2, 3}
```
## 字符串 ##
字符串本质上是一个结构体：
```
type StringHeader struct {
	Data uintptr  //字符串指向的底层字节数组
	Len  int       //字符串的字节的长度
}
```
字符串相关的强制类型转换主要涉及到 []byte 和 []rune 两种类型。每个转换都可能隐含重新分配内存的代价，最坏的情况下它们的运算时间复杂度都是 O(n)。不过字符串和 []rune 的转换要更为特殊一些，因为一般这种强制类型转换要求两个类型的底层内存结构要尽量一致，显然它们底层对应的 []byte 和 []int32 类型是完全不同的内部布局，因此这种转换可能隐含重新分配内存的操作。

golang中byte数据类型与rune相似，它们都是用来表示字符类型的变量类型。它们的不同在于：  
 
*byte 等同于int8，常用来处理ascii字符  
*rune 等同于int32,常用来处理unicode或utf-8字符
