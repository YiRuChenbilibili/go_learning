# 定义及声明 #
## 短变量声明并初始化 ##
如果 变量 已经被声明过，但依然使用:=时编译器会报错，如下：  
`<no new variables on left side of :=>`  
意思是，在“:=”的左边没有新变量出现，意思就是“:=”的左边变量已经被声明了。  
_在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错_，代码如下：  
`conn, err := net.Dial("tcp", "127.0.0.1:8080")`  
`conn2, err := net.Dial("tcp", "127.0.0.1:8080")`

#  数组、字符串和切片 #
## 数组 ##  
数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。数组的长度是数组类型的组成部分。因为数组的长度是数组类型的一个部分，不同长度或不同类型的数据组成的数组都是不同的类型（[4]int,[5]int是不同的类型），因此在**Go 语言中很少直接使用数组（不同长度的数组因为类型不同无法直接赋值_。**  
定义方式:  
```
  var a [3]int                    // 定义长度为 3 的 int 型数组, 元素全部为 0    
  var b = [...]int{1, 2, 3}       // 定义长度为 3 的 int 型数组, 元素为 1, 2, 3   
  var c = [...]int{2: 3, 1: 2}    // 定义长度为 3 的 int 型数组, 元素为 0, 2, 3   
  var d = [...]int{1, 2, 4: 5, 6} // 定义长度为 6 的 int 型数组, 元素为 1, 2, 0, 0, 5, 6
```
Go 语言中数组是值语义。一个数组变量即表示整个数组，它并不是隐式的指向第一个元素的指针（比如 C 语言的数组），而是一个完整的值。当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。如果数组较大的话，数组的赋值也会有较大的开销。为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。
```
var a = [...]int{1, 2, 3} // a 是一个数组
var b = &a                // b 是指向数组的指针
for i, v := range b {     // 通过数组指针迭代数组的元素
	fmt.Println(i, v)
}
```
但是数组指针类型依然不够灵活，因为数组的长度是数组类型的组成部分，**指向不同长度数组的数组指针类型也是完全不同的。**
长度为 0 的数组在内存中并不占用空间。空数组虽然很少直接使用，但是可以用于*强调某种特有类型的操作时避免分配额外的内存空间。*
可以用 fmt.Printf 函数提供的 %T 或 %#v 谓词语法来打印数组的类型和详细信息：
```
	fmt.Printf("b: %T\n", b)  // b: [3]int
	fmt.Printf("b: %#v\n", b) // b: [3]int{1, 2, 3}
```
## 字符串 ##
字符串本质上是一个结构体：
```
type StringHeader struct {
	Data uintptr  //字符串指向的底层字节数组
	Len  int       //字符串的字节的长度
}
```
字符串相关的强制类型转换主要涉及到 []byte 和 []rune 两种类型。每个转换都可能隐含重新分配内存的代价，最坏的情况下它们的运算时间复杂度都是 O(n)。不过字符串和 []rune 的转换要更为特殊一些，因为一般这种强制类型转换要求两个类型的底层内存结构要尽量一致，显然它们底层对应的 []byte 和 []int32 类型是完全不同的内部布局，因此这种转换可能隐含重新分配内存的操作。

golang中byte数据类型与rune相似，它们都是用来表示字符类型的变量类型。它们的不同在于：  
 
*byte 等同于int8，常用来处理ascii字符  
*rune 等同于int32,常用来处理unicode或utf-8字符*

##切片##
切片就是一种简化版的动态数组。因为动态数组的长度是不固定，所以**切片的长度不能是类型的组成部分了。**
切片的结构定义，reflect.SliceHeader：
```
type SliceHeader struct {
	Data uintptr  
	Len  int
	Cap  int   //切片指向的内存空间的最大容量（对应元素的个数，而不是字节数）
}
```
切片定义方式：
```
var (
	a []int               // nil 切片, 和 nil 相等, 一般用来表示一个不存在的切片
	b = []int{}           // 空切片, 和 nil 不相等, 一般用来表示一个空的集合
	c = []int{1, 2, 3}    // 有 3 个元素的切片, len 和 cap 都为 3
	d = c[:2]             // 有 2 个元素的切片, len 为 2, cap 为 3
	e = c[0:2:cap(c)]     // 有 2 个元素的切片, len 为 2, cap 为 3
	f = c[:0]             // 有 0 个元素的切片, len 为 0, cap 为 3
	g = make([]int, 3)    // 有 3 个元素的切片, len 和 cap 都为 3
	h = make([]int, 2, 3) // 有 2 个元素的切片, len 为 2, cap 为 3
	i = make([]int, 0, 3) // 有 0 个元素的切片, len 为 0, cap 为 3
)
```
**遍历切片:**
```
	for i := range a {
		fmt.Printf("a[%d]: %d\n", i, a[i])
	}
	for i, v := range b {
		fmt.Printf("b[%d]: %d\n", i, v)
	}
```
**添加切片元素(尾部)：**
```
var a []int
a = append(a, 1)               // 追加 1 个元素
a = append(a, 1, 2, 3)         // 追加多个元素, 手写解包方式
a = append(a, []int{1,2,3}...) // 追加 1 个切片, 切片需要解包
```
在容量不足的情况下，append 的操作会导致重新分配内存，可能导致巨大的内存分配和复制数据代价。即使容量足够，依然需要用 append 函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。
**添加切片元素(头部)：**
```
var a = []int{1,2,3}
a = append([]int{0}, a...)        // 在开头添加 1 个元素
a = append([]int{-3,-2,-1}, a...) // 在开头添加 1 个切片
```
append 函数支持链式操作，因此可以将多个 append 操作组合起来，实现在切片中间插入元素：
```var a []int
a = append(a[:i], append([]int{x}, a[i:]...)...)     // 在第 i 个位置插入 x
a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第 i 个位置插入切片
//或使用copy
a = append(a, 0)     // 切片扩展 1 个空间
copy(a[i+1:], a[i:]) // a[i:] 向后移动 1 个位置
a[i] = x             // 设置新添加的元素
```
**删除切片元素**  
删除切片尾部:
```
a = []int{1, 2, 3}
a = a[:len(a)-1]   // 删除尾部 1 个元素
a = a[:len(a)-N]   // 删除尾部 N 个元素
```
删除开头的元素:
```
//移动数据指针
a = []int{1, 2, 3}
a = a[1:] // 删除开头 1 个元素
a = a[N:] // 删除开头 N 个元素
//原地完成
a = []int{1, 2, 3}
a = append(a[:0], a[1:]...) // 删除开头 1 个元素
a = append(a[:0], a[N:]...) // 删除开头 N 个元素

```
删除中间的元素：
```
a = []int{1, 2, 3, ...}

a = append(a[:i], a[i+1:]...) // 删除中间 1 个元素
a = append(a[:i], a[i+N:]...) // 删除中间 N 个元素

a = a[:i+copy(a[i:], a[i+1:])]  // 删除中间 1 个元素
a = a[:i+copy(a[i:], a[i+N:])]  // 删除中间 N 个元素
```
切片高效操作的要点是要降低内存分配的次数，尽量保证 append 操作不会超出 cap 的容量，降低触发内存分配的次数和每次分配内存大小。
**避免切片内存泄漏**
切片操作并不会复制底层的数据。底层的数组会被保存在内存中，直到它不再被引用。但是有时候可能会因为一个小的内存引用而导致底层整个数组处于被使用的状态，这会延迟自动内存回收器对底层数组的回收。  
*当切片引用了整个原始数组时，会导致自动垃圾回收器不能及时释放底层数组的空间。一个小的需求可能导致需要长时间保存整个文件数据。*  
要修复这个问题，可以将感兴趣的数据**复制到一个新的切片中**（数据的传值是 Go 语言编程的一个哲学，虽然传值有一定的代价，但是换取的好处是**切断了对原始数据的依赖**）：
```
func FindPhoneNumber(filename string) []byte {
	b, _ := ioutil.ReadFile(filename)
	b = regexp.MustCompile("[0-9]+").Find(b)
	return append([]byte{}, b...)   //复制到一个新的切片
}
```
